// Generated by CoffeeScript 1.6.3
(function() {
  var God, Particles, World, pass, __DEBUG__;

  __DEBUG__ = false;

  pass = void 0;

  God = (function() {
    function God() {}

    God.setup = function() {
      var c;
      this.deviceWidth = 640.0;
      this.deviceHeight = 480.0;
      this.scene = new THREE.Scene();
      this.scene.fog = new THREE.FogExp2(0x000000, 0.08);
      this.camera = new THREE.PerspectiveCamera(60, this.deviceWidth / this.deviceHeight, Math.pow(0.1, 8), Math.pow(10, 3));
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(this.deviceWidth, this.deviceHeight);
      this.renderer.setClearColor(0x7788cc, 0);
      c = document.getElementById('c');
      c.appendChild(this.renderer.domElement);
      World.setup(this.scene);
      return this.particles = new Particles(this.scene);
    };

    God.start = function() {
      var render, startTime,
        _this = this;
      startTime = +new Date();
      render = function() {
        _this.tick = new Date() - startTime;
        _this.particles.update();
        _this.camera.position.z = Math.sin(_this.tick * 0.00022) * 3;
        _this.camera.position.y = Math.sin(_this.tick * 0.000093) * 3 + 2.0;
        _this.camera.position.x = Math.cos(_this.tick * 0.000054) * 3;
        if (Math.random() < 0.001 || _this.cameraTarget === void 0) {
          _this.cameraTarget = _this.particles.particles[~~(Math.random() * _this.particles.particles.length)].p;
        }
        _this.camera.lookAt(_this.cameraTarget);
        requestAnimationFrame(render);
        return _this.renderer.render(_this.scene, _this.camera);
      };
      return render();
    };

    return God;

  })();

  World = (function() {
    function World() {}

    World.setup = function(scene) {
      var vertices;
      World.size = this.size = 5;
      vertices = [new THREE.Vector3(-this.size, -this.size, -this.size), new THREE.Vector3(this.size, -this.size, -this.size), new THREE.Vector3(this.size, this.size, -this.size), new THREE.Vector3(-this.size, this.size, -this.size), new THREE.Vector3(-this.size, -this.size, this.size), new THREE.Vector3(this.size, -this.size, this.size), new THREE.Vector3(this.size, this.size, this.size), new THREE.Vector3(-this.size, this.size, this.size)];
      this.geometry = new THREE.Geometry();
      this.geometry.vertices.push(vertices[0], vertices[1], vertices[2], vertices[3], vertices[7], vertices[4], vertices[5], vertices[6], vertices[2], vertices[6], vertices[7], vertices[3], vertices[0], vertices[4], vertices[5], vertices[1]);
      this.material = new THREE.LineBasicMaterial({
        color: 0xffffff,
        opacity: 0.3,
        depthTest: false,
        transparent: true,
        blending: THREE.AdditiveBlending
      });
      this.mesh = new THREE.Line(this.geometry, this.material);
      return scene.add(this.mesh);
    };

    return World;

  })();

  Particles = (function() {
    var Node, NodeManager, Particle;

    Particles.prototype.capacity = 100;

    Particle = (function() {
      function Particle(p) {
        var s;
        this.p = p;
        s = 0.01;
        this.sp = new THREE.Vector3(Math.random() * s - s * 2, Math.random() * s - s * 2, Math.random() * s - s * 2);
        this.numberingUID();
      }

      Particle.prototype.numberingUID = function() {
        if (Particle._uid === void 0) {
          Particle._uid = 0;
        }
        return this.uid = Particle._uid++;
      };

      return Particle;

    })();

    Node = (function() {
      function Node(scene, f, p) {
        this.scene = scene;
        this.f = f;
        this.p = p;
        this.material = this.makeMaterial();
        this.geometry = new THREE.Geometry();
        this.geometry.vertices.push(this.f.p, this.p.p);
        this.mesh = new THREE.Line(this.geometry, this.material);
        this.scene.add(this.mesh);
      }

      Node.prototype.makeMaterial = function() {
        return Node.material = new THREE.LineBasicMaterial({
          color: 0x222244,
          depthTest: false,
          transparent: true,
          linewidth: 2,
          blending: THREE.AdditiveBlending
        });
      };

      Node.prototype.update = function() {
        return this.geometry.verticesNeedUpdate = true;
      };

      Node.prototype.activate = function() {
        return this.mesh.visible = true;
      };

      Node.prototype.unactivate = function() {
        return this.mesh.visible = false;
      };

      return Node;

    })();

    NodeManager = (function() {
      function NodeManager() {
        this.nodes = [];
      }

      NodeManager.prototype.set = function(x, y, p) {
        var _ref;
        if (x > y) {
          _ref = [x, y], y = _ref[0], x = _ref[1];
        }
        if (this.nodes[x] === void 0) {
          this.nodes[x] = [];
        }
        return this.nodes[x][y] = p;
      };

      NodeManager.prototype.get = function(x, y) {
        var _ref;
        if (x > y) {
          _ref = [x, y], y = _ref[0], x = _ref[1];
        }
        if (!this.nodes[x][y]) {
          console.log(x, y);
        }
        return this.nodes[x][y];
      };

      NodeManager.prototype.update = function() {
        var n, nn, x, _i, _len, _ref, _results;
        x = 0;
        _ref = this.nodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          nn = _ref[_i];
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = nn.length; _j < _len1; _j++) {
              n = nn[_j];
              if (n) {
                _results1.push(n.update());
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        }
        return _results;
      };

      return NodeManager;

    })();

    function Particles(scene) {
      var i, material, mesh, particle, vertex, w, x, y, _i, _j, _k, _ref, _ref1, _ref2, _ref3;
      this.scene = scene;
      this.particles = [];
      this.geometry = new THREE.Geometry();
      for (i = _i = 0, _ref = this.capacity; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        w = World.size;
        vertex = new THREE.Vector3(Math.random() * w * 2 - w, Math.random() * w * 2 - w, Math.random() * w * 2 - w);
        this.geometry.vertices.push(vertex);
        particle = new Particle(vertex);
        this.particles.push(particle);
      }
      material = new THREE.PointCloudMaterial({
        size: 0.2,
        map: this.makeTexture(),
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthTest: false
      });
      mesh = new THREE.PointCloud(this.geometry, material);
      this.scene.add(mesh);
      this.nm = new NodeManager();
      for (x = _j = 0, _ref1 = this.capacity; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
        for (y = _k = _ref2 = x + 1, _ref3 = this.capacity; _ref2 <= _ref3 ? _k < _ref3 : _k > _ref3; y = _ref2 <= _ref3 ? ++_k : --_k) {
          this.nm.set(x, y, new Node(this.scene, this.particles[x], this.particles[y]));
        }
      }
    }

    Particles.prototype.makeTexture = function(tp) {
      var canvas, ctx, grad, height, texture, width;
      canvas = document.createElement('canvas');
      width = canvas.width = 256;
      height = canvas.height = 256;
      ctx = canvas.getContext('2d');
      grad = ctx.createRadialGradient(width / 2, height / 2, width / 8, width / 2, height / 2, width / 2);
      grad.addColorStop(0, 'rgb(96, 96, 128)');
      grad.addColorStop(0.03, 'rgb(32, 32, 64)');
      grad.addColorStop(0.30, 'rgb(32, 32, 255)');
      grad.addColorStop(1, 'rgb(0, 0, 0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.rect(0, 0, width, height);
      ctx.fill();
      if (__DEBUG__) {
        document.body.appendChild(canvas);
      }
      texture = THREE.ImageUtils.loadTexture(canvas.toDataURL());
      return texture;
    };

    Particles.prototype.update = function() {
      var dist, i1, i2, node, p, p1, p2, ss, w, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      for (i1 = _i = 0, _ref = this.capacity; 0 <= _ref ? _i < _ref : _i > _ref; i1 = 0 <= _ref ? ++_i : --_i) {
        p1 = this.particles[i1];
        for (i2 = _j = _ref1 = i1 + 1, _ref2 = this.capacity; _ref1 <= _ref2 ? _j < _ref2 : _j > _ref2; i2 = _ref1 <= _ref2 ? ++_j : --_j) {
          p2 = this.particles[i2];
          ss = 0.0001;
          dist = p1.p.distanceTo(p2.p);
          if (dist < 2) {
            if (dist < 0.08) {
              ss *= -10000;
            }
            p1.sp.x -= (p1.p.x - p2.p.x) * ss;
            p1.sp.y -= (p1.p.y - p2.p.y) * ss;
            p1.sp.z -= (p1.p.z - p2.p.z) * ss;
          }
        }
      }
      _ref3 = this.particles;
      for (_k = 0, _len = _ref3.length; _k < _len; _k++) {
        p = _ref3[_k];
        ss = 0.995;
        p.sp.x *= ss;
        p.sp.y *= ss;
        p.sp.z *= ss;
        p.p.x += p.sp.x;
        p.p.y += p.sp.y;
        p.p.z += p.sp.z;
        w = World.size;
        if (p.p.x > w) {
          p.p.x = -w;
        }
        if (p.p.x < -w) {
          p.p.x = w;
        }
        if (p.p.y > w) {
          p.p.y = -w;
        }
        if (p.p.y < -w) {
          p.p.y = w;
        }
        if (p.p.z > w) {
          p.p.z = -w;
        }
        if (p.p.z < -w) {
          p.p.z = w;
        }
      }
      for (i1 = _l = 0, _ref4 = this.capacity; 0 <= _ref4 ? _l < _ref4 : _l > _ref4; i1 = 0 <= _ref4 ? ++_l : --_l) {
        p1 = this.particles[i1];
        for (i2 = _m = _ref5 = i1 + 1, _ref6 = this.capacity; _ref5 <= _ref6 ? _m < _ref6 : _m > _ref6; i2 = _ref5 <= _ref6 ? ++_m : --_m) {
          p2 = this.particles[i2];
          node = this.nm.get(i1, i2);
          dist = p1.p.distanceTo(p2.p);
          if (dist < 2) {
            node.activate();
          } else {
            node.unactivate();
          }
        }
      }
      this.geometry.verticesNeedUpdate = true;
      return this.nm.update();
    };

    return Particles;

  })();

  window.God = God;

}).call(this);

/*
//@ sourceMappingURL=pm.map
*/
